[{"content":"It\u0026rsquo;s a-me! # ","date":"16 May 2022","permalink":"/blog/","section":"","summary":"It\u0026rsquo;s a-me!","title":""},{"content":"","date":"16 May 2022","permalink":"/tags/algorithms/","section":"Tags","summary":"","title":"Algorithms"},{"content":"","date":"16 May 2022","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"16 May 2022","permalink":"/tags/coding/","section":"Tags","summary":"","title":"Coding"},{"content":"","date":"16 May 2022","permalink":"/tags/data-structures/","section":"Tags","summary":"","title":"Data Structures"},{"content":"","date":"16 May 2022","permalink":"/","section":"Dylan Powers","summary":"","title":"Dylan Powers"},{"content":"","date":"16 May 2022","permalink":"/tags/interview/","section":"Tags","summary":"","title":"Interview"},{"content":"","date":"16 May 2022","permalink":"/categories/interviewing/","section":"Categories","summary":"","title":"Interviewing"},{"content":"","date":"16 May 2022","permalink":"/tags/software-engineering/","section":"Tags","summary":"","title":"Software Engineering"},{"content":"","date":"16 May 2022","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"Today at work, I needed to solve the knapsack problem for an important feature. I had to figure out how to put n items into a knapsack of weight at most W, and maximize the total cost.\nAfter that, I was working on a feature with a graph, and I had to figure out the minimum number of nodes that could be removed while maintaining a connected network.\nTo wrap up the day, product asked me to find the longest common substring between two strings for a client.\n Actually, none of this happened. Most of my day actually involves writing business logic for our system, discussing specifications with product, reviewing code, and monitoring deployments. I’m willing to bet that, if you’re a software engineer, your day looks somewhat like this as well, with some minor differences.\nUnless you work at LeetCode, it’s unlikely that you encounter the problems I mentioned above more than once or twice a year, if at all. These are abstract topics that we scarcely see outside of coding interviews. However, we have widely accepted that coding interviews should and will be like this for the foreseeable future. I ask, though: why are tech companies often evaluating software engineers on their knowledge of dynamic programming, graph theory, and niche algorithms if they are scarcely used on the job?\nI argue that knowledge of these topics is not a direct indicator of how well somebody will perform on the job. I still believe we need to evaluate coding ability (obviously), but I think and know that we can do better than the current system. I’ll outline my thoughts here.\nThe Argument For # The main argument for these types of interviews is that they demonstrate the candidate’s thinking style. Companies look for candidates who think out loud and who can translate their thoughts into code. I completely understand that. I think the ability to translate abstract concepts in your mind to code on the screen is the crux of software engineering.\nLet me walk you through a typical coding interview. The candidate receives the prompt, and remembers the general approach for tackling these kinds of problems - an approach they likely learned on LeetCode. The candidate begins to outline their approach, pulling in learnings from previous LeetCode problems, and combining them to form a plan. Then, the candidate translates those thoughts into code and writes some test cases.\nYes, the candidate demonstrated the ability to translate their thoughts into code. But what thoughts did they translate? Likely, they translated thoughts about past LeetCode problems and abstract concepts. Can we really say that those are thoughts that the candidate will have on the job? It’s more likely that thoughts on the job will be related to architecting systems, creating simple APIs for others to consume, reviewing code for style, designing database schemas, etc.\nThe Ideal Interview # As I mentioned above, companies still need to assess software engineers on their ability to translate thoughts into code. Companies also need to get a glimpse into how a candidate reasons about a problem from start to finish. Finally, companies should still require a proficiency with basic data structures (maps, lists, queues, etc.). We can still accomplish this with a different style of interview.\nIn my opinion, the ideal engineer can write clean, maintainable code with an easy-to-use API. I propose that we begin to ask engineers more questions about designing entire classes with multiple pieces of functionality**,** rather than just implementing singular methods with a clear expected answer.\nFor example, a company could ask a candidate to design an in-memory message broker. We would expect methods for enqueue and poll, and we would encourage the candidate to add any other methods they see fit (maybe to get the number of currently enqueued messages),\nIn this scenario, there is no one correct answer, so a candidate would not fail solely because they did not generate the correct output. Instead, we would evaluate candidates more holistically:\n How readable is the code? Are variables named well? How maintainable is the code? Are pieces of functionality split out into methods? How easy-to-use is the API? Could another team easily consume this? Are implementation details hidden?  I believe that these assessments more accurately reflect skills that the candidate would actually use on the job.\n As an industry that powers so much of the world, we can and should do better with evaluating candidates. Companies often miss out on top talent just because a candidate can’t solve the knapsack problem, find the minimum number of nodes that can be removed to maintain a connected graph, or find the maximum length substring of two strings. Let’s start evaluating candidates on skill used on the job.\n Header image courtesy of iMocha .\n","date":"16 May 2022","permalink":"/blog/what-coding-interviews-should-be/","section":"","summary":"My vision of what coding interviews should involve.","title":"What Coding Interviews Should Be"},{"content":"Popovers are a crucial part of any modern web application. Simply put, a popover is a small modal that pops over the screen when the user hovers or clicks somewhere. Usually this comes in the form of a menu, but it could also be a drawer popping out from the left or right side of the screen.\nWhen creating a web application, developers usually reach for a component library like Material UI or Antd . Recently when playing around with Material (hereafter referred to as MUI), I reached for the Popover component. Here, I’ll discuss the implementation details of this component as to uncover one crucial limitation that necessitated my own custom implementation.\nMUI Popover Implementation # The way the MUI popover component works is by first receiving an anchor element as a prop. The anchor element is usually whatever div the click or hover event is coming from; MUI uses this to determine where to place the popover. However, the popover itself does not get attached anywhere in the hierarchy of the anchor element. Instead, it gets attached to a new div which is a sibling of the root element (usually where ReactDOM.render is first called).\nLet’s call this new div root-sibling. This new div will take up the entire width and height of the viewport. The reason for this is to register a custom click handler that will cause the popover to close whenever the user clicks anywhere on the screen outside of the popover. Without knowing specifics, I’m assuming this click handler is registered on mount.\nThis behavior introduces a crucial limitation - out of the box, we cannot allow the screen to continue to process hover events when the popover is open. For example, say we have a menu which opens a different popover for each menu item on hover. If we use the MUI popover out of the box, then those other menu items will be masked by root-sibling whenever any popover is open, and nothing will happen when the user hovers those elements.\nFurthermore, setting pointer-events: none on root-sibling will not work, because this will cause the popover to just always stay open no matter where the user clicks (I believe the escape key would still work, though). So what are we to do if we want the hover behavior to be preserved?\nCustom Implementation # In order to continue to process other hover events and close the popover whenever the user clicks outside of it, I used a combination of the pointer-events: none styling and a custom click handler.\nFirst, we should style the Popover MUI component with pointer-events: none. However, we need to take care to still process the click events inside of the popover, otherwise the user will not be able to interact with menu elements. So, on the highest-level div inside of the Popover component, make sure to style with pointer-events: auto.\nNext, we need to register a custom click handler which will cause the popover to be closed whenever the user clicks outside of it. We will register this on the highest-level div inside of the component. We will first need a ref for that div, so that we can check where the click is. Use React’s useRef hook to generate that ref, and then pass it to that div:\n// PopoverContent.tsx export default function PopoverContent() { const ref = useRef\u0026lt;HTMLElement | null\u0026gt;(null); return ( \u0026lt;div ref={ref}\u0026gt; Content goes here \u0026lt;/div\u0026gt; ); } Then, on mount, we will register the click handler. We can grab the bounding rectangle for the ref, and then use that to check where the click is. If the click is outside of that rectangle, then we should close the popover, most likely using some prop. We also need to make sure to remove the click handler on unmount. We can do all of this inside of a useEffect hook:\n// PopoverContent.tsx const { handleClose }: { handleClose: () =\u0026gt; void } = props; useEffect(() =\u0026gt; { if (!ref || !ref.current) { return; } const rect: DOMRect = ref.current.getBoundingClientRect(); const eventListener = (event: MouseEvent) =\u0026gt; { if ( event.clientX \u0026lt; rect.left || event.clientX \u0026gt; rect.right || event.clientY \u0026lt; rect.top || event.clientY \u0026gt; rect.bottom ) { handleClose(); } }; document.addEventListener(\u0026#34;mousedown\u0026#34;, eventListener); return () =\u0026gt; document.removeEventListener(\u0026#34;mousedown\u0026#34;, eventListener); }, [ref, ref.current]); And there we have it! Now we will be able to successfully process hover events while preserving the desired click behavior.\n","date":"21 February 2022","permalink":"/blog/creating-robust-popovers-in-react/","section":"","summary":"A tutorial on creating robust popovers using Material UI.","title":"Creating Robust Popovers in React using Material UI"},{"content":"","date":"21 February 2022","permalink":"/tags/frontend/","section":"Tags","summary":"","title":"Frontend"},{"content":"","date":"21 February 2022","permalink":"/tags/material/","section":"Tags","summary":"","title":"Material"},{"content":"","date":"21 February 2022","permalink":"/tags/mui/","section":"Tags","summary":"","title":"MUI"},{"content":"","date":"21 February 2022","permalink":"/tags/react/","section":"Tags","summary":"","title":"React"},{"content":"","date":"21 February 2022","permalink":"/categories/react/","section":"Categories","summary":"","title":"React"},{"content":"","date":"21 February 2022","permalink":"/tags/tsx/","section":"Tags","summary":"","title":"TSX"},{"content":"","date":"21 February 2022","permalink":"/tags/typescript/","section":"Tags","summary":"","title":"Typescript"},{"content":"","date":"22 August 2021","permalink":"/tags/camera/","section":"Tags","summary":"","title":"Camera"},{"content":"","date":"22 August 2021","permalink":"/tags/laptop/","section":"Tags","summary":"","title":"Laptop"},{"content":"","date":"22 August 2021","permalink":"/tags/microphone/","section":"Tags","summary":"","title":"Microphone"},{"content":"","date":"22 August 2021","permalink":"/tags/monitor/","section":"Tags","summary":"","title":"Monitor"},{"content":"My company has allowed us to return to the office on a voluntary basis (requiring proof of vaccination). I go every day because I really value being able to discuss something easily without having to set up a Zoom meeting. Also, how could anybody possibly say no to free snacks and coffee?\nDespite the abundant nourishment, there is one thing I miss about the roughly 10 months of work-from-home that I did - my setup! I spent a lot of time researching and refining my setup, so I want to share it with the world.\nMonitors # For monitors, I have two 27\u0026quot; LG 27UL500-W 4K monitors (Amazon ). I have them mounted using a dual arm mount , which allows me to move them around very easily.\nHaving used both 4K and non-4K monitors, I will say that 4K is 100% worth the extra price. Even moving to a 1440p monitor feels so much different after experiencing 4K resolution for so long.\nAs far as configuration, I have one monitor directly in front of me and one directly to the right of it, tilted toward me. Currently, both are horizontal, but I had the right one oriented vertically for about half of WFH. It was really useful for code, but I still find that it is easier to manage multiple applications when viewing them horizontally.\nI also have my laptop on the left side of my desk on a simple laptop stand .\nMouse # I had a very cheap $10 mouse for most of WFH, which treated me well. However, until I upgraded, I never knew what I was missing out on. I recently bought the Logitech MX Master 3 (Amazon ), and it completely changed the game. The ergonomics are absolutely incredible, it\u0026rsquo;s configurable beyond belief, and it has a horizontal scroll wheel (more handy than you might think).\nI have an extended mousepad that I also put my keyboard on. It has seen it\u0026rsquo;s fair share of spills, so it may be time to replace it soon.\nKeyboard # Currently, I am using the Apple Magic Keyboard with an additional numeric keypad (Apple ). I have it in black, which matches my mouse and mouse pad exquisitely. I have thought a lot about upgrading to a mechanical soon. I ordered a switch tester (big brown fan) and will order once I feel that I have researched enough.\nCamera # I have the Logitech C922x Pro Stream Webcam (Amazon ) sitting on top of the monitor directly in front of me. It has excellent video quality, but the part that really surprised me is the audio quality. It comes with a built-in microphone that works incredibly well.\n My setup is always a work in progress, but I feel that I have made a good start. There\u0026rsquo;s just a few more things that I need - plants, plants, and more plants!\n","date":"22 August 2021","permalink":"/blog/my-2021-work-from-home-setup/","section":"","summary":"An overview of my current desk setup","title":"My 2021 Work From Home Setup"},{"content":"","date":"22 August 2021","permalink":"/categories/other/","section":"Categories","summary":"","title":"Other"},{"content":"","date":"22 August 2021","permalink":"/tags/setup/","section":"Tags","summary":"","title":"Setup"},{"content":"","date":"22 August 2021","permalink":"/tags/wfh/","section":"Tags","summary":"","title":"WFH"},{"content":"","date":"15 August 2021","permalink":"/tags/hooks/","section":"Tags","summary":"","title":"Hooks"},{"content":"","date":"15 August 2021","permalink":"/tags/javascript/","section":"Tags","summary":"","title":"Javascript"},{"content":"","date":"15 August 2021","permalink":"/tags/usecallbackl/","section":"Tags","summary":"","title":"useCallbackl"},{"content":"I\u0026rsquo;ve worked with React a lot over the past few years. The more I work with it, the more I notice common mistakes that can slow down rendering as they pile up. Granted, in small applications (like most side projects), usually the rendering slowness will go unnoticed due to the size of the application. However, for larger applications, thinking about rendering speed becomes important.\nOne issue I see often is wrapping all function declarations in a component inside of a useCallback hook. As per the React docs:\n useCallback will return a memoized version of the callback that only changes if one of the dependencies has changed.\n Essentially, without useCallback, the function will be recreated on every render. It\u0026rsquo;s important to remember that in JavaScript, functions are first-class objects just like a normal Object is. This essentially just means that the function can be stored as a variable, passed as an argument to a function, and returned from a function.\nWithout useCallback # Let\u0026rsquo;s say we have a function createUser that is going to create a user by making an API call. The user details are stored in pieces of state within the component.\n// SignupPage.jsx const [email, setEmail] = useState(\u0026#39;\u0026#39;); const [password, setPassword] = useState(\u0026#39;\u0026#39;); const createUser = () =\u0026gt; { UserAPI.createUser(email, password); redirectToHome(); }; We will return some JSX that will render the input elements, so we don\u0026rsquo;t need to rely on other components to render the input form. Whenever a piece of state changes, React will re-render the component. This will recreate (among other things) all functions not wrapped in a useCallback.\nThis means that the createUser function above is created once for each render. This can become a larger performance hit in larger applications, but I\u0026rsquo;ll show in the next section why it isn\u0026rsquo;t the end of the world for this case.\nWith useCallback # Alternatively, we can wrap the function in a useCallback hook provided by the React library. This means that the function will not be re-evaluated unless something in the dependency array changes. Assuming that UserAPI and the redirectToHome function are both created outside of the component, we just need to declare email and password as dependencies.\n// SignupPage.jsx const [email, setEmail] = useState(\u0026#39;\u0026#39;); const [password, setPassword] = useState(\u0026#39;\u0026#39;); const createUser = useCallback(() =\u0026gt; { UserAPI.createUser(email, password); redirectToHome(); }, [email, password]); This means that, unless the email or password state changes, we will not recreate the createUser function. For example, if we had some showInfoModal state that would show some information about signing up, we could change that state without recreating the createUser function.\nThis seems like an improvement, right? Consider the fact that the above code is actually identical to the following:\n// SignupPage.jsx const [email, setEmail] = useState(\u0026#39;\u0026#39;); const [password, setPassword] = useState(\u0026#39;\u0026#39;); const nonMemoizedCreateUser = () =\u0026gt; { UserAPI.createUser(email, password); redirectToHome(); }; const createUser = useCallback(nonMemoizedCreateUser, [email, password]); So, the original function is actually still created, and we are doing even more work than before! In this instance, it seems quite wasteful. However, there are situations where useCallback is worth the extra cost.\nUse it With Memoized Components # The best use case for useCallback is when creating memoized components; that is, components wrapped in an extra React.memo() function. This means that the component will not re-render unless the props actually change (or, of course, component-held state changes).\nConsider a situation where we have a separate Button component which will call the passed-in function when clicked. This component has a single prop representing the createUser function.\nimport React, { memo } from \u0026#39;react\u0026#39;; const Button = (props) =\u0026gt; { return ( \u0026lt;button onclick={props.createUser}\u0026gt;Create User\u0026lt;/button\u0026gt; ); }; export default memo(Button); This means that the Button component will not re-render unless the props change (React by default defines a \u0026ldquo;change\u0026rdquo; by shallowly comparing the current props to the previous props). If in the SignupPage component we do not wrap the function in a useCallback, then the reference will change every time, causing the Button component to re-render every time that the SignupPage component re-renders. However, if we wrap the prop in a useCallback, then we have much more fine-grained control over when the Button component re-renders.\n When making decisions on whether or not to use useCallback, there are always several factors at play. However, when relying on memoized components, wrapping function props in useCallbacks is always a safe bet.\n","date":"15 August 2021","permalink":"/blog/when-to-use-usecallback/","section":"","summary":"When to actually use the useCallback function in React","title":"When to Use useCallback"},{"content":"When I was first starting out in React development, I had little to no knowledge about the ecosystem in general. Not knowing the necessary tools available in the ecosystem definitely led to increased time-to-completion for personal projects. In this post, I\u0026rsquo;ll discuss NPM packages that I use every day in my personal React projects which have sped up development time drastically, and are great for beginners.\ncreate-react-app # This is the #1 package out there for bootstrapping React applications. It allows you to create scaffolds for React applications with a simple command: create-react-app \u0026lt;project name\u0026gt;. This package is maintained by Facebook, so you can be sure that it will always contain the most recent optimizations.\nantd # The antd package, short for Ant Design, is a library of React components created by Ant Financial . Creating UI components can be an extremely time consuming part of development, and self-created components don\u0026rsquo;t make for a great user experience if you don\u0026rsquo;t have great design skills (like myself).\nantd provides simple, out-of-the-box components for everything from lists to tables to rating systems. Everything is standardized which makes for a great user experience, and you can even override the CSS variables using something like craco . I\u0026rsquo;ve made several websites with antd components and I always have a great time using it.\nstyled-components # styled-components is a library for styling React components (or standard HTML elements) directly in your component file. By default, it exports a function styled which accepts a React component as an argument and applies extra styling on top of it. For example, we can add extra styles to antd\u0026rsquo;s Button component like so:\nimport { Button } from \u0026#39;antd\u0026#39;; import styled from \u0026#39;styled-components\u0026#39;; const PaddedButton = styled(Button)` padding: 10px; `; There is a short-hand for applying the styling on HTML elements where you can just use a .:\nimport styled from \u0026#39;styled-components\u0026#39;; const RedText = styled.p` color: red; `; I love styled-components because I can style the components in the way I need without ever leaving the component file. In my opinion, the close coupling of component\u0026rsquo;s styles to their state management makes for a simpler development workflow.\nNote: be sure to always define your styled components outside of the component that uses them, so that they aren\u0026rsquo;t re-computed on every render.\nreact-router-dom # This is simply the easiest and best routing package out there. It gives you a set of navigational components that you can use to declare different routes in your application like the main page, a /login page, a /profile page, etc. You declare your different routes with Route components, and then designate which component they should render:\nimport { Route, Switch, Router } from \u0026#39;react-router-dom\u0026#39;; import LoginPage from \u0026#39;./LoginPage\u0026#39;; export default function App(props) { return ( \u0026lt;Router\u0026gt; \u0026lt;Switch\u0026gt; \u0026lt;Route exact path=\u0026#34;/login\u0026#34; component={LoginPage} /\u0026gt; \u0026lt;/Switch\u0026gt; \u0026lt;/Router\u0026gt; ); } I\u0026rsquo;ve also written separate post on how to make protected routes using this package.\nfirebase # Firebase is more just than a package - it provides tools for everything that basic applications need like authentication, storage, and much more. It provides a declarative and simple API that makes app development incredibly simple.\nTo use this package, you\u0026rsquo;ll need to create a firebase account and project. After that, you can set up authentication as well as a real-time datastore or a collection-like datastore similar to MongoDB .\naxios # Axios is a simple HTTP client for making API requests from the browser. It\u0026rsquo;s also promise-based which means you can add success callbacks with ease.\nclassnames # Classnames is an incredible simple yet extremely powerful library. It does one thing and it does it well - conditionally combining CSS class names based on a set of criteria. It exports a function which takes a single object argument where the keys are the class names and the values are booleans representing whether or not to apply the class name. Here\u0026rsquo;s a simple example where something should have the highlighted class if a piece of state is true:\nimport classNames from \u0026#39;classnames\u0026#39;; export default function List(props) { const [isHighlighted, setIsHighlighted] = useState(false); const listItemClassName = classNames({ \u0026#39;list-item\u0026#39;: true, \u0026#39;highlighted\u0026#39;: isHighlighted }); }  With these packages, you can supercharge your React development. Go out and develop!\n","date":"8 August 2021","permalink":"/blog/essential-npm-packages-for-react-beginners/","section":"","summary":"A collection of NPM packages which comprise an excellent toolset for beginners.","title":"Essential NPM Packages for React Beginners"},{"content":"","date":"8 August 2021","permalink":"/tags/jsx/","section":"Tags","summary":"","title":"JSX"},{"content":"","date":"8 August 2021","permalink":"/tags/npm/","section":"Tags","summary":"","title":"NPM"},{"content":"","date":"9 May 2021","permalink":"/tags/components/","section":"Tags","summary":"","title":"Components"},{"content":"","date":"9 May 2021","permalink":"/tags/context/","section":"Tags","summary":"","title":"Context"},{"content":"With the rising popularity of React, we are in an era of the most responsive user interfaces we have ever seen. React uses a virtual DOM, and for every render it runs calculations to determine which parts of the actual DOM need to get updated. This means that React only re-renders components that need to be re-rendered, and nothing more.\nHowever, that doesn\u0026rsquo;t mean we shouldn\u0026rsquo;t introduce optimizations of our own! Too many re-renders can lead to performance issues, so we should optimize wherever we can. One common pitfall I see in React applications is what I call messenger components, which are components that pass some props from a parent to a child, but do not actually do anything with those props. For example, consider the following three components.\nfun ction Parent(props) { const foo = 1; const bar = 2; return ( \u0026lt;Child foo={foo} bar={bar} /\u0026gt; ); } function Child(props) { return ( \u0026lt;\u0026gt; \u0026lt;p\u0026gt;Foo is {props.foo}\u0026lt;/p\u0026gt; \u0026lt;Grandchild bar={props.bar} /\u0026gt; \u0026lt;/\u0026gt; ); } function Grandchild(props) { return ( \u0026lt;p\u0026gt;Bar is {props.bar}\u0026lt;/p\u0026gt; ); } In this situation, Child receives both foo and bar as props, but only truly \u0026ldquo;cares\u0026rdquo; about the value of foo; Grandchild cares about the value of bar. In this case, Child is a messenger component for the bar prop. Child should only re-render when the value of foo updates, but in this case it will also re-render when bar updates. How can we fix this?\nThe Context API # Using React\u0026rsquo;s Context API , we can broadcast changes to values, and only components that directly subscribe to that piece of context will receive the new value. This solves the problem of messenger components re-rendering unnecessarily, because we no longer need to pass props down - we can simply directly subscribe to the value in Grandchild. To demonstrate this, I will add refs to show the number of re-renders for each component before and after adding context.\nBefore # Using the current system of prop drilling, we can see how Child will re-render every time either prop is updated. If you like, use create-react-app to bootstrap an app to see the renders in action.\nfunction Parent(props) { const [foo, setFoo] = useState(0); const [bar, setBar] = useState(0); function incrementFoo() { setFoo((prev) =\u0026gt; prev + 1); } function incrementBar() { setBar((prev) =\u0026gt; prev + 1); } return ( \u0026lt;\u0026gt; \u0026lt;button onClick={incrementFoo}\u0026gt;Increment Foo\u0026lt;/button\u0026gt; \u0026lt;button onClick={incrementBar}\u0026gt;Increment Bar\u0026lt;/button\u0026gt; \u0026lt;Child foo={foo} bar={bar} /\u0026gt; \u0026lt;/\u0026gt; ); } function Child(props) { const renders = useRef(0); return ( \u0026lt;\u0026gt; \u0026lt;p\u0026gt;Foo (in Child): {props.foo}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Child renders: {renders.current++}\u0026lt;/p\u0026gt; \u0026lt;Grandchild bar={bar} /\u0026gt; \u0026lt;/\u0026gt; ); } function Grandchild(props) { const renders = useRef(0); return ( \u0026lt;\u0026gt; \u0026lt;p\u0026gt;Bar (in Grandchild): {props.bar}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Grandchild renders: {renders.current++}\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } If you run this application, you will notice that the number of renders for the Child and Grandchild components will always be the same. However, since Child doesn\u0026rsquo;t need to update when bar updates, the number of re-renders shouldn\u0026rsquo;t be the same for the two components.\nBut wait, why don\u0026rsquo;t we just memoize Child so that it only re-renders when foo updates? Beware of this approach, because it is only half of the solution! Memoizing Child to not re-render when bar is updated leaves nothing to re-render Grandchild, so this will result in unintended consequences: Grandchild would only re-render when foo is updated.\nAfter # Using a combination of memoization and the Context API, we can prevent Child from re-rendering unnecessarily. The following application demonstrates this:\nconst BarContext = createContext(null); function Parent(props) { const [foo, setFoo] = useState(0); const [bar, setBar] = useState(0); function incrementFoo() { setFoo((prev) =\u0026gt; prev + 1); } function incrementBar() { setBar((prev) =\u0026gt; prev + 1); } return ( \u0026lt;BarContext.Provider value={bar}\u0026gt; \u0026lt;button onClick={incrementFoo}\u0026gt;Increment Foo\u0026lt;/button\u0026gt; \u0026lt;button onClick={incrementBar}\u0026gt;Increment Bar\u0026lt;/button\u0026gt; \u0026lt;MemoizedChild foo={foo} /\u0026gt; \u0026lt;/BarContext.Provider\u0026gt; ); } function Child(props) { const renders = useRef(0); return ( \u0026lt;\u0026gt; \u0026lt;p\u0026gt;Foo (in Child): {props.foo}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Child renders: {renders.current++}\u0026lt;/p\u0026gt; \u0026lt;Grandchild /\u0026gt; \u0026lt;/\u0026gt; ); } const MemoizedChild = memo(Child); function Grandchild(props) { const renders = useRef(0); const bar = useContext(BarContext); return ( \u0026lt;\u0026gt; \u0026lt;p\u0026gt;Bar (in Grandchild): {bar}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Grandchild renders: {renders.current++}\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); } As you can see, we made two updates. First, we used a piece of context to hold the reference to bar, and we have Grandchild subscribe to that piece of context using the useContext hook. However, this is only half of the equation; if we do not memoize Child, then anytime bar is updated in Parent, Child will re-render. In order to prevent this, we use the memo function to create a memoized version of the Child component that will only re-render when the props change.\nAnd voila! We have successfully eliminated unnecessary messenger re-renders with the Context API and some simple memoization.\nI would be remiss not to say that for most applications, re-renders don\u0026rsquo;t cause much of a performance issue because most applications don\u0026rsquo;t involve a lot of front-end computation. However, for applications with a lot of animations or drag-and-drops, it\u0026rsquo;s more than worth it to eliminate unnecessary re-renders wherever you can. Happy coding!\n","date":"9 May 2021","permalink":"/blog/using-context-to-prevent-unnecessary-re-renders/","section":"","summary":"Using React\u0026rsquo;s Context API to prevent unnecessary re-renders in React applications.","title":"Using Context to Prevent Unnecessary Re Renders"},{"content":"","date":"2 February 2021","permalink":"/tags/mobile/","section":"Tags","summary":"","title":"Mobile"},{"content":"","date":"2 February 2021","permalink":"/tags/react-redux/","section":"Tags","summary":"","title":"React-Redux"},{"content":"","date":"2 February 2021","permalink":"/tags/redux/","section":"Tags","summary":"","title":"Redux"},{"content":"When it comes to frontend state management libraries, it doesn\u0026rsquo;t get much better than good ol' Redux . It allows you to define one or more reducers, dispatch updates to a global state, and subscribe to only the parts of state that you care about in each a component.\nHowever, as I have continued to incorporate Redux into smaller personal projects, I have found some of its features to be superfluous to my needs. For example, for small projects that make use of Ajax, I sometimes prefer to separate the global state from the Ajax calls. This makes something like redux-thunk unnecessary, meaning that I would not make use of any Redux middleware (fun fact: the redux-thunk library is only 14 lines of source code ).\nFortunately, implementing a basic Redux is much simpler than you might think! We just need a custom reducer and a couple of React hooks. This tutorial will show you how to create a simple global state, along with a dispatcher and a way to update that global state. We will be using functional components in this tutorial, and we will create a simple counter which can be incremented and decremented. Let\u0026rsquo;s get started!\nThe Reducer # For starters, a reducer is just a function which accepts a current state and an action and then based on that action, returns a new state. That\u0026rsquo;s it. However, without some active management, you would have to keep track of the current state and pass it to the reducer every time you wanted to dispatch an action.\nFortunately, React already covers a lot of the ground for us with the useReducer hook. It accepts two arguments: a reducer and an initial state (it also optionally accepts a lazy state initialization function). The reducer must have the signature described above:\nfunction reducer(state, action) { return state; // some new state } To begin with, we\u0026rsquo;ll define our reducer in its own file. We will also define the action types for incrementing, decrementing, and setting the counter:\n// reducer.js const INCREMENT = \u0026#39;INCREMENT\u0026#39;; const DECREMENT = \u0026#39;DECREMENT\u0026#39;; const SET_COUNT = \u0026#39;SET_COUNT\u0026#39;; export default function counter(state, action) { switch (action.type) { case INCREMENT: return state + 1; case DECREMENT: return state - 1; case SET_COUNT: return action.count; default: throw new Error(`Action type ${action.type}not recognized`); } } We\u0026rsquo;ll also want to make some action creators, which simplify the process of constructing an action from outside of the scope of the reducer. Actions are just objects which have a type property and, optionally, other properties. To avoid having to create the action object inside of a component, we define certain action creators in the reducer:\n// reducer.js export function increment() { return { type: INCREMENT }; } export function decrement() { return { type: DECREMENT }; } export function setCount(count) { return { type: SET_COUNT, count }; } With the reducer done, we can now begin to make our Redux functionality using a couple useful hooks.\nIncorporating the Reducer # The useReducer hook returns a dispatch function and a reference to the current state. The dispatch function takes care of automatically passing in the current state to the reducer, although we still have to supply the action (this emulates Redux behavior).\nIn our top-level component where we want the global state to live, we declare our dispatch function and our global state using this hook:\n// TopLevelComponent.jsx import React, { useReducer } from \u0026#39;react\u0026#39;; import reducer from \u0026#39;./reducer\u0026#39;; export default function TopLevelComponent(props) { const [count, dispatch] = useReducer(reducer, 0); return ( \u0026lt;p\u0026gt;The current count is {count}.\u0026lt;/p\u0026gt; ); } Then, any time an action is dispatched using the dispatch function returned above, the global count will be updated! Now this is beginning to look a little like Redux. However, if the dispatch function were simply passed down through props, you might think that this looks like plain React: passing down callbacks to update state in a parent component. And you would be right. Using another hook, we can make this app even more Redux-like.\nMaking dispatch Available Everywhere # To further emulate Redux, we should make the dispatch function available from any child component without directly passing it down through props. In the parent component, we can provide a context whose value is the dispatch function. In order to be able to access this context later, we will declare it in the reducer file:\n// reducer.js import { createContext } from \u0026#39;react\u0026#39;; export const CounterContext = createContext(null); Then, in our top-level component, we will wrap all children in a context provider that will provide the dispatch function to all child components:\n// TopLevelComponent.jsx import React, { useReducer } from \u0026#39;react\u0026#39;; import reducer, { CounterContext } from \u0026#39;./reducer\u0026#39;; export default function TopLevelComponent(props) { const [count, dispatch] = useReducer(reducer, 0); return ( \u0026lt;CounterContext.Provider value={dispatch}\u0026gt; \u0026lt;p\u0026gt;The current count is {count}.\u0026lt;/p\u0026gt; \u0026lt;/CounterContext.Provider\u0026gt; ); } Now, any child component will have access to the dispatch function, which they can use to update the count state globally! If you wish to access count in child components as well, it would be trivial to make another context to provide that value anywhere.\nDispatching Actions from Child Components # Now, for the pièce de résistance! By using the useContext hook, we can access the value of the created context from any child component and dispatch actions to the global state, just like Redux:\n// ChildComponent.jsx import React, { useContext } from \u0026#39;react\u0026#39;; import { CounterContext, increment, decrement } from \u0026#39;./reducer\u0026#39;; export default function ChildComponent(props) { const dispatch = useContext(CounterContext); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch(increment())}\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch(decrement())}\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } As you can see, now we can access the dispatch function from anywhere to dispatch actions to the global state without having to pass down callbacks as props.\n As you can see, we have now covered all of our bases in terms of basic Redux functionality. We can:\n Define a reducer which updates a global state Dispatch actions to update that global state Access the dispatch function from any child component  For simple projects, this quasi-Redux implements a lot of the basic functionality without having to incorporate the whole library. Thanks for reading 😄!\n","date":"2 February 2021","permalink":"/blog/redux-without-redux-how-to-create-redux-like-functionality-using-react/","section":"","summary":"Create a simple Redux-like module using pure React","title":"Redux Without Redux: How to Create Redux-like Functionality Using React"},{"content":"","date":"2 February 2021","permalink":"/tags/web/","section":"Tags","summary":"","title":"Web"},{"content":"","date":"8 September 2020","permalink":"/tags/auth/","section":"Tags","summary":"","title":"Auth"},{"content":"","date":"8 September 2020","permalink":"/tags/jwt/","section":"Tags","summary":"","title":"JWT"},{"content":"If you have ever made a modern single-page web app using React, odds are you used react-router-dom for client-side routing. In this tutorial, I will demonstrate how to protect routes such that only logged-in users can navigate to certain places. For example, you don\u0026rsquo;t want every user to be able to navigate to /dashboard, but anybody should be able to hit /login.\nThis tutorial assumes that you have basic familiarity with react-router-dom and how to set up a basic router. If not, please read its quick start page before moving on. This article also assumes that you have a simple way to determine if a user is logged in or not, whether that be through JSON web tokens , Redux , or something else.\nOverview # A traditional React router without protected routes might look something like this:\nimport React from \u0026#39;react\u0026#39;; import { BrowserRouter, Switch, Route } from \u0026#39;react-router-dom\u0026#39;; import LoginPage from \u0026#39;./components/LoginPage\u0026#39;; import DashboardPage from \u0026#39;./components/DashboardPage\u0026#39;; export default function Router() { return ( \u0026lt;BrowserRouter\u0026gt; \u0026lt;Switch\u0026gt; \u0026lt;Route to=\u0026#34;/login\u0026#34; component={LoginPage} /\u0026gt; \u0026lt;Route to=\u0026#34;/dashboard\u0026#34; component={DashboardPage} /\u0026gt; \u0026lt;Route component={DashboardPage} /\u0026gt; \u0026lt;/Switch\u0026gt; \u0026lt;/BrowserRouter\u0026gt; ); } There is an issue with this setup; if a user tries to navigate to /dashboard, they will be able to do so without logging in. Especially if the dashboard contains sensitive information, this is dangerous behavior. To remedy this, we will be replacing the Route components with references to our new ProtectedRoute components, which will redirect to a different page (in our case, /login) if the user is not logged in.\nCreating the Component # First, we will create the ProtectedRoute component. In this tutorial I will be using a functional component, but class-based components work as well. Create a new file ProtectedRoute.js and place the following inside of it:\nexport default function ProtectedRoute({ component: Component, ...rest }) { } This means that our ProtectedRoute will expect a component prop, much like how Route from react-router-dom takes a component prop. The ...rest part refers to the rest of the props that can be passed to ProtectedRoute besides the component.\nImporting Auth Logic # Next, we need to import auth logic into this module to determine whether or not the user is logged in. As I mentioned earlier, I use JSON web tokens, but as long as you have a function that returns a boolean indicating whether or not the user is logged in, everything will work great. At this point, our file will look like this:\nimport { isAuthenticated } from \u0026#39;../auth/jwt\u0026#39;; export default function ProtectedRoute({ component: Component, ...rest }) { } Protecting the Route # These next 5 lines of code are where the real magic happens. We will be using react-router-dom\u0026rsquo;s Redirect component to redirect to a universally accessible page if the user is not logged in. Otherwise, we will return its Route component, which is what you see in a regular React router.\nWe will pass the ...rest parameter to the Route component, which means that everything that we pass to ProtectedRoute (except for the component prop) will then be passed to the Route component. We will take advantage of Route\u0026rsquo;s render prop to make it render the component passed in to our protected route:\n\u0026lt;Route {...rest} render={(props) =\u0026gt; \u0026lt;Component {...props} /\u0026gt;} /\u0026gt; Of course, we will only return this route if the user is logged in. If not, we will return a Redirect to the login page. After adding the logic and the imports in the file, it should look like this:\nimport React from \u0026#39;react\u0026#39;; import { Redirect, Route } from \u0026#39;react-router-dom\u0026#39;; export default function ProtectedRoute({ component: Component, ...rest }) { return isAuthenticated() ? ( \u0026lt;Route {...rest} render={(props) =\u0026gt; \u0026lt;Component {...props} /\u0026gt;} /\u0026gt; ) : ( \u0026lt;Redirect to=\u0026#34;/login\u0026#34; /\u0026gt; ); } Alternatively, if you do not want to always redirect to the login page, consider adding adding a prop like redirectRoute to the component:\nexport default function ProtectedRoute({ component: Component, redirectRoute, ...rest }) { // ... } And then the redirect component would read \u0026lt;Redirect to={redirectRoute} /\u0026gt;.\nPutting it All Together # Now, anytime we want to protect a route, we can use our ProtectedRoute component instead of the provided Route component. As a result, the router shown in the overview would now look like this:\nimport React from \u0026#39;react\u0026#39;; import { BrowserRouter, Switch, Route } from \u0026#39;react-router-dom\u0026#39;; import LoginPage from \u0026#39;./components/LoginPage\u0026#39;; import DashboardPage from \u0026#39;./components/DashboardPage\u0026#39;; import ProtectedRoute from \u0026#39;./utils/ProtectedRoute\u0026#39;; export default function Router() { return ( \u0026lt;BrowserRouter\u0026gt; \u0026lt;Switch\u0026gt; \u0026lt;Route to=\u0026#34;/login\u0026#34; component={LoginPage} /\u0026gt; \u0026lt;ProtectedRoute to=\u0026#34;/dashboard\u0026#34; component={DashboardPage} /\u0026gt; \u0026lt;ProtectedRoute component={DashboardPage} /\u0026gt; \u0026lt;/Switch\u0026gt; \u0026lt;/BrowserRouter\u0026gt; ); } Voilà! You now have the ability to make protected routes in React. Go protect those web apps!\n","date":"8 September 2020","permalink":"/blog/protected-routes-in-react/","section":"","summary":"A short tutorial on how to protect routes using React-Router-Dom.","title":"Protected Routes in React using React-Router-Dom"},{"content":"","date":"8 September 2020","permalink":"/tags/react-router-dom/","section":"Tags","summary":"","title":"React-Router-Dom"},{"content":"","date":"8 September 2020","permalink":"/tags/security/","section":"Tags","summary":"","title":"Security"},{"content":"","date":"8 September 2020","permalink":"/categories/tutorials/","section":"Categories","summary":"","title":"Tutorials"},{"content":"","date":"24 June 2020","permalink":"/tags/authentication/","section":"Tags","summary":"","title":"Authentication"},{"content":"","date":"24 June 2020","permalink":"/tags/firebase/","section":"Tags","summary":"","title":"Firebase"},{"content":"In this post, I will show you how to use the react-redux-firebase package to incorporate Redux bindings for Firebase into your React project. This allows you to incorporate Firebase and Firestore data into global state without any extra work, as well as handle auth in a super simple way. If you are unfamiliar with React , Redux , or Firebase , please spend some time familiarizing yourself with those before jumping in.\nThis is not a beginning-to-end tutorial; rather, I will show you how the react-redux-firebase (RRF) package to make your app flow much simpler. For setup instructions, check out the documentation .\nAuth # Sign In # First, I will show you how this package makes auth in your application so much simpler. Without RRF, you would have to perform the sign in flow and then dispatch an action to the store with the user information; then, any time you needed that, you would have to use a useSelector hook to get that sign in information. It might look something like this:\nimport React from \u0026#39;react\u0026#39;; import firebase from \u0026#39;firebase\u0026#39;; import { useDispatch } from \u0026#39;react-redux\u0026#39;; export default function Component() { const dispatch = useDispatch(); function signIn(email, password) { firebase.auth().signInWithEmailAndPassword(email, password) .then((userCredential) =\u0026gt; dispatch({ type: \u0026#39;AUTH\u0026#39;, user: userCredential })).catch((err) =\u0026gt; console.error(err)); } function signOut() { firebase.auth().signOut() .then(() =\u0026gt; dispatch({ type: \u0026#39;AUTH\u0026#39;, user: undefined })).catch((err) =\u0026gt; console.error(err)); } // ... } Then when you want to query for the currently signed-in user in another component, you would do something like\nconst user = useSelector((state) =\u0026gt; state.auth); However, when you use the useFirebase hook provided by react-redux-firebase, you don\u0026rsquo;t have to dispatch any actions:\nimport React from \u0026#39;react\u0026#39;; import { useFirebase } from \u0026#39;react-redux-firebase\u0026#39;; export default function Component() { const firebase = useFirebase(); function signIn(email, password) { firebase.signIn({ email, password }).catch((err) =\u0026gt; console.error(err)); } function signOut() { firebase.signOut() .catch((err) =\u0026gt; console.error(err)); } // ... } That\u0026rsquo;s it! No extra state for you to handle, RRF does it all internally. Then, simply query for the currently signed-in user as such:\nconst user = useSelector((state) =\u0026gt; state.firebase.auth); Registration # If you also want to store some extra data on the side, such as user firstName and lastName, you specify that when you sign up a user, as the second argument to the createUser() call. This makes that information readily available in the store as part of the profile.\nimport React from \u0026#39;react\u0026#39;; import { useFirebase } from \u0026#39;react-redux-firebase\u0026#39;; export default function Component() { const firebase = useFirebase(); function register(email, password, firstName, lastName) { firebase.createUser({ email, password }, { email, firstName, lastName }).catch((err) =\u0026gt; console.error(err)); } // ... } In this example, email, firstName, and lastName are all stored as part of the user\u0026rsquo;s profile. You can access this information anywhere using the profile part of the store:\nconst { email, firstName, lastName } = useSelector((state) =\u0026gt; state.firebase.profile); Isn\u0026rsquo;t that awesome?\nData Storage # Cloud Firestore # Firestore, being a document-oriented database, is my preference when developing an app on top of Firebase. The Firestore JavaScript SDK provides listeners that automatically listen for changes in Firestore documents. However, if you want to listen for changes to an entire collection and update state accordingly, the code becomes quite clunky:\nimport React from \u0026#39;react\u0026#39;; import { useDispatch, useSelector } from \u0026#39;react-redux\u0026#39;; import firebase from \u0026#39;firebase\u0026#39;; export default function Component() { const dispatch = useDispatch(); const todos = useSelector((state) =\u0026gt; state.todos); firebase.firestore().collection(\u0026#39;todos\u0026#39;) .onSnapshot((querySnapshot) =\u0026gt; { const updatedTodos = {}; querySnapshot.forEach((doc) =\u0026gt; { updatedTodos[doc.id] = doc.data(); }); dispatch({ type: \u0026#39;TODOS_UPDATED\u0026#39;, todos: updatedTodos }); }); // ... } However, with RRF\u0026rsquo;s useFirestoreConnect hook, you can attach a listener that will automatically listen and unlisten as needed, and you can make the data a part of Redux state.\nimport React from \u0026#39;react\u0026#39;; import { useFirestoreConnect } from \u0026#39;react-redux-firebase\u0026#39;; export default function Component() { useFirestoreConnect({ collection: \u0026#39;todos\u0026#39; }); const todos = useSelector((state) =\u0026gt; state.firestore.data.todos); // ... } In the two above examples, both todos variables with evaluate to the same thing; there are two obvious differences:\n The first example involves much more code, and is much harder to read. The second example requires no manual global state management, as that is managed by the hook.  This extremely useful hook also offers three other really cool features:\n  If you have a nested collection, you can choose how the listener stores the collection as part of global state. For example, if you have a nested collection baz which is located at foo/bar/baz, then without this feature you would have to select the collection as follows:\nconst baz = useSelector((state) =\u0026gt; state.firestore.data.foo.bar.baz); However, using the storeAs argument, you can easily change it to anything you like:\nuseFirestoreConnect({ collection: \u0026#39;foo/bar/baz\u0026#39;, storeAs: \u0026#39;baz\u0026#39; }); const baz = useSelector((state) =\u0026gt; state.firestore.data.baz);   If you use the ordered property of firestore instead of data, the data will become sorted. To change how the data is sorted, pass an orderBy argument to the hook:\nuseFirestoreConnect({ collection: \u0026#39;foo/bar/baz\u0026#39;, orderBy: \u0026#39;createdAt\u0026#39;, storeAs: \u0026#39;baz\u0026#39; }); const baz = useSelector((state) =\u0026gt; state.firestore.ordered.baz);   If you just want to listen to a specific document (rather than an entire collection), that\u0026rsquo;s entirely possible too. You will still have to select the individual document, but the listener will only listen to the single document, not the entire collection:\nuseFirestoreConnect({ collection: \u0026#39;foo\u0026#39;, doc: \u0026#39;bar\u0026#39; }); const bar = useSelector((state) =\u0026gt; state.firestore.data.foo[\u0026#39;bar\u0026#39;]);   Absolutely amazing.\nReal-time Database # The custom hook useFirebaseConnect for listening to the real-time database is very similar to the above example, with a few differences based on the general difference between the two query languages. Before RRF, you would have to fetch data from a path like this:\nimport React from \u0026#39;react\u0026#39;; import { useDispatch, useSelector } from \u0026#39;react-redux\u0026#39;; import firebase from \u0026#39;firebase\u0026#39;; export default function Component() { const dispatch = useDispatch(); const todos = useSelector((state) =\u0026gt; state.todos); firebase.database().ref(\u0026#39;todos\u0026#39;) .on(\u0026#39;value\u0026#39;, (snapshot) =\u0026gt; { dispatch({ type: \u0026#39;TODOS_UPDATED\u0026#39;, todos: snapshot.val() }); }); // ... } However, by using the useFirebaseConnect hook, we no longer have to manually manage global state. Instead, the hook manages listening and unlistening as well as updating our global state:\nimport React from \u0026#39;react\u0026#39;; import { useSelector } from \u0026#39;react-redux\u0026#39;; import { useFirebaseConnect } from \u0026#39;react-redux-firebase\u0026#39;; export default function Component() { useFirebaseConnect({ path: \u0026#39;todos\u0026#39; }); const todos = useSelector((state) =\u0026gt; state.firebase.data.todos); // ... } Isn\u0026rsquo;t that much cleaner? You can also use special query parameters to change how the data is sorted, among other things:\nuseFirebaseConnect({ path: \u0026#39;todos\u0026#39;, queryParams: [\u0026#34;orderByKey\u0026#34;] }); const todos = useSelector((state) =\u0026gt; state.firebase.ordered.todos); Basically, anything that you could do with the standard SDK, the hook exposes to you as well.\nConclusion # If you\u0026rsquo;re developing an app with React, Redux, and Firebase, then you should be using this library to make your code much cleaner. Auth has never been simpler. Plus, the custom Firebase and Firestore hooks do so much extra leg work for you, so you can focus on writing application code.\nNote: header image taken from this tutorial from Aberraouf Zine .\n","date":"24 June 2020","permalink":"/blog/how-to-use-react-redux-firebase/","section":"","summary":"A short tutorial on how to use this really cool package bringing together the best of React, Redux, and Firebase.","title":"How to Use React-Redux-Firebase"},{"content":"","date":"24 June 2020","permalink":"/tags/react-redux-firebase/","section":"Tags","summary":"","title":"React-Redux-Firebase"},{"content":"","date":"24 June 2020","permalink":"/tags/usefirebaseconnect/","section":"Tags","summary":"","title":"useFirebaseConnect"},{"content":"","date":"24 June 2020","permalink":"/tags/usefirestoreconnect/","section":"Tags","summary":"","title":"useFirestoreConnect"},{"content":"","date":"24 June 2020","permalink":"/tags/user/","section":"Tags","summary":"","title":"User"},{"content":"Perhaps made most famous by Facebook\u0026rsquo;s \u0026ldquo;Move Fast, Break Things\u0026rdquo; mantra, the philosophy of iterating extremely quickly has become proliferate in the tech world. Tools like JIRA, GitHub, and suites of CI/CD tools give teams no excuse to not push out products and updates as quickly as they can. However, as an organization grows, developers need to take into account scalability and flexibility of codebases. As such (at least from what I have observed), larger organizations tend to slow down over time to accommodate more scrutinous code reviews and technological research.\n   Over the past five months, I have been a Software Engineer for OurSpace , a real-time Q\u0026amp;A platform for locations and spaces. Currently, we have released a full working product at Duke University, and we plan to expand as we continue to perfect our core product. Working on a startup means that we do move extremely quickly; a lot quicker than anything I am used to. This might mean pushing out hundreds of lines of code every day to meet our strict deadlines and release goals. As such, we often do not have time to waste with overly scrutinous code reviews and setting up rigorous CI/CD pipelines.\nAt least, that\u0026rsquo;s what I thought at first. Since then, I have realized that while we do need to hit deadlines, investing a little bit more time into flexibility really pays off in the long run. In this article, I aim to explain why it\u0026rsquo;s important to strike that balance between moving quickly and developing flexible, robust code.\nCreating Reusable Interfaces # Part of the excitement of working on a startup is the freedom in choosing which technologies to use - this also means switching technologies often. This means that, especially on the server-side, creating reusable interfaces is invaluable, as it allows future devs to easily swap out implementations.\nWhen developing quickly, it\u0026rsquo;s really easy to fall into the mindset of \u0026ldquo;I\u0026rsquo;m just going to make a class that works right now, so there\u0026rsquo;s no need to create an interface.\u0026rdquo; Yes, the development process will be easier now, but what happens in the future when another developer has to swap out the implementation? They will spend at least twice as long as they would if you had just made an interface.\nTo give you an example: when we first started on this journey, we used Google\u0026rsquo;s Cloud Firestore for all of our data storage. This meant clients on the backend for communicating with our Firestore. Luckily enough, our early developers created a DbClient interface that declared methods for communicating with whatever db we chose, so when we finally made the choice to migrate to MongoDB , the transition was effortless. Even though we lost some early development time creating these interfaces, we more than made up for it by saving a plethora of time swapping out our implementation.\n   Documenting Patterns # Writing good documentation is yet another action that most reserve for medium-to-large companies only. It\u0026rsquo;s also something that takes time which could be \u0026ldquo;better spent\u0026rdquo; working on features and moving us toward our project goals. However, despite the initial overhead, writing down our most-used design patterns in plain English has saved us countless time.\nI recommend creating a wiki for all different areas of development; for us, that includes server-side, our iOS client, and DevOps, among others. In that wiki, write down all of the common practices used throughout the organization so that developers can turn to it when initially planning out a feature. This saves developers a lot of time that would otherwise be spent either brainstorming a new design (convoluting the existing codebase) or mapping out existing code to understand how a design works. Writing it down in plain English will take 5-10 minutes, but will save developers hours of time in the future.\nAutomating Processes # This should go without saying, but always reserve time at the beginning to automate everything. Run tests on every push. Connect GitHub to your messaging platform to get notifications whenever a PR is created. Deploy whenever a PR is closed. While this may cost some time at the beginning doing research on automation tools, the amount of time saved is astronomical. Please, set some time aside right now, and ask how you can best automate your current workflow.\n   Protip: GitHub Actions are a really cool and easy way to automate workflows if you use GitHub for hosting.\n Working on a startup has been incredibly challenging given the required speed of development. However, as I continue to develop mass amounts of code daily, I thank my past self for designing things well enough to make development for present-day me much easier. When embarking on this long, rewarding journey, don\u0026rsquo;t fall into the \u0026ldquo;move fast\u0026rdquo; mentality unless you append \u0026ldquo;in an well-thought out manner\u0026rdquo; to the end of it.\n","date":"9 February 2020","permalink":"/blog/striking-the-balance-development-in-a-fast-moving-startup/","section":"","summary":"Perhaps made most famous by Facebook\u0026rsquo;s \u0026ldquo;Move Fast, Break Things\u0026rdquo; mantra, the philosophy of iterating extremely quickly has become proliferate in the tech world.","title":"Striking the Balance: Development in a Fast-Moving Startup"},{"content":"","date":"27 August 2019","permalink":"/tags/brooklyn/","section":"Tags","summary":"","title":"Brooklyn"},{"content":"","date":"27 August 2019","permalink":"/tags/flatiron/","section":"Tags","summary":"","title":"Flatiron"},{"content":"","date":"27 August 2019","permalink":"/tags/intern/","section":"Tags","summary":"","title":"Intern"},{"content":"","date":"27 August 2019","permalink":"/tags/manhattan/","section":"Tags","summary":"","title":"Manhattan"},{"content":"","date":"27 August 2019","permalink":"/tags/new-york/","section":"Tags","summary":"","title":"New York"},{"content":"","date":"27 August 2019","permalink":"/tags/new-york-city/","section":"Tags","summary":"","title":"New York City"},{"content":"","date":"27 August 2019","permalink":"/tags/pigeon/","section":"Tags","summary":"","title":"Pigeon"},{"content":"","date":"27 August 2019","permalink":"/tags/subway/","section":"Tags","summary":"","title":"Subway"},{"content":"","date":"27 August 2019","permalink":"/tags/summer/","section":"Tags","summary":"","title":"Summer"},{"content":"This past summer I worked at Yext in New York City. Our office is located at the corner of 23rd and Madison Avenue, right next to the famous Flatiron Building, pictured below.\n   Living in New York was the best experience in my life, and I want to share some tips on how to have both a productive and fun summer in New York; I hope future interns can make use of this guide.\nIf You Work in Manhattan, Live in Manhattan # I made the mistake of living in Brooklyn, which made my 8-stop commute on the F train quite long. My roommate and I grabbed an Airbnb for a much cheaper price, but we still regret not living in the city. Most students live in admittedly-small dorms, but the location is all that matters. After a night out, taking the train home at 3am is the least appealing thing in the world, and Ubers can often break the bank. Just live in Manhattan.\nMake Plans Every Night # An actual conversation I had with my mentor this summer:\n Dylan, do you have plans tonight?\nNo, not tonight.\nWhy not? It\u0026rsquo;s New York!\n After that, I made a conscious effort to always find an event to go to or make plans to go to dinner with someone after work. Luckily, a fellow intern at my company compiled a calendar of free events in New York over the summer, so I just added that to my Google Calendar. If I\u0026rsquo;m only going to spend 3 months in the greatest city on Earth, I might as well make the most of it. You should too.\nUse Pigeon for the Subway # Pigeon is a crowdsourced transit app for the subway in New York City. Not only can you plan trips and see which lines stop where, but you can also see reports of lines/stations that have problems. On July 13th, the power went out in some of Manhattan, and a lot of lines stopped running. My sister (who was visiting) and I waited in the station for twenty minutes before I finally checked Pigeon and realized what had happened. Without the app, we probably would have waited longer.\nAlso, be a good samaritan and post on the app! If something is going on, let people know. Good Karma pays off!\nWait for the Train Outside the Station # No joke, it\u0026rsquo;s 10-15 degrees Fahrenheit hotter in the station. The trains feel great, but the stations feel like standing in the middle of the Sahara Desert wearing a suit made out of tin foil. Get on your phone, check the arrival time on the app, and wait outside until the train is three or so minutes away.\nUse Yelp to Find Restaurants # Since there are so many restaurants in Manhattan, deciding what to eat feels impossible sometimes. However, whenever going out with friends, we always used Yelp to decide what to eat. It never failed once.\nPro tip: since you\u0026rsquo;re only there for a short time, use the 4-star or higher filter.\nI hope everyone gets the opportunity to spend a summer in New York. It really goes by quickly, so it\u0026rsquo;s important to pack as much as possible into the short time frame. Have fun in the greatest city on Earth!\n","date":"27 August 2019","permalink":"/blog/tips-for-a-summer-in-new-york/","section":"","summary":"This past summer I worked at Yext in New York City.","title":"Tips for a Summer in New York"},{"content":"","date":"27 August 2019","permalink":"/tags/train/","section":"Tags","summary":"","title":"Train"},{"content":"","date":"15 August 2019","permalink":"/tags/amazon/","section":"Tags","summary":"","title":"amazon"},{"content":"","date":"15 August 2019","permalink":"/tags/apple/","section":"Tags","summary":"","title":"apple"},{"content":"","date":"15 August 2019","permalink":"/tags/books/","section":"Tags","summary":"","title":"books"},{"content":"One of my favorite things about the summers is how much time I have to catch up on reading. Admittedly I have more fun reading at home than in the crowded F train to Manhattan, but I worked with what I had this summer. Over the course of the summer, I read 6 books, and I want to share my experience with each of them, in the order that I read them. Here it goes:\nSmarter, Faster, Better by Charles Duhigg #    I read one of Duhigg\u0026rsquo;s other books, The Power of Habit, and I loved it so much that I just had to buy his new book. It did not disappoint. His description of productivity and the tools he gives to enhance day-to-day output are unparalleled.\nDuhigg does an amazing job of giving real-world examples of situations, and showing how people apply his principles to become more productive people. More than just a productivity guide, though, this book also describes how effective teams function together and how people can best internalize information.\nBiggest Takeaway: His chapter on internalizing information really stuck with me, because I\u0026rsquo;m a firm believer in lifelong learning. He talks about the importance of not only receiving information, but immediately applying it to a real-world situation:\n The people who are most successful at learning\u0026hellip; are the ones who know how to use disfluency to their advantage. They transform what life throws at them, rather than just taking it as it comes. (264)\n As I try to advance in my career, having the ability to really internalize large amounts of information will prove extremely useful, and I owe it to Duhigg for helping me learn ways to do that.\nFind this book on Amazon .\nLiar\u0026rsquo;s Poker by Michael Lewis #    For those that don\u0026rsquo;t know Michael Lewis, he wrote such books-turned-movies as Moneyball and The Big Short. He is an extremely gifted storyteller known for his incredibly engaging descriptions of real world events.\nIn Liar\u0026rsquo;s Poker, he takes a turn and writes a book about his own experience on Wall Street in the 80\u0026rsquo;s. He worked for Salomon Brothers , one of the biggest firms at the time. Throughout the book, he weaves his own experiences in with vivid descriptions of how Salomon Brothers worked internally. They are quite unflattering descriptions.\nA large part of the book centers around the training sessions that all new traders had to endure (note use of the word \u0026ldquo;endure\u0026rdquo;) before making their way onto the floor. Lewis could not believe how childish some of his colleagues were; they were often caught throwing paper balls at the lecturers. He also includes a lot of technical economic jargon, but tries to explain it in a way that anybody could digest.\nBiggest Takeaway: Wall Street was, and always will be, a cutthroat environment. Traders have little to no regard for their customers, and often try to f*ck them over (as Lewis did to one Frenchman - read the book to find out). However, some people are just always meant to be screwed over:\n You are proof that some people are born to be customers. (213)\n Find this book on Amazon .\nThe Four by Scott Galloway #    Galloway, a professor at NYU, paints a not-so-pretty picture of four firms that have shaped our current way of life: Apple, Amazon, Facebook, and Google. He begins the book with a chapter on each of the four companies, each one seeming to get more and more critical. Fun fact: Amazon actually took this book off of their online store for a while. Yay for freedom of speech violations!\nHe then continues on to explain why these companies do so well, and how they are going to continue to do even better. He also describes the potential outcome of letting these companies expand indeterminately, and what we can do to help. Finally, he ends with advice on how to succeed in a world where these companies dominate.\nHe mostly argues that, given the extreme amount of money that these firms have, they are morally wrong for not putting it to better use. For example, Amazon spents a huge amount on new innovative technologies each year, about 50% of which fail and are never mentioned or addressed ever again. What if Amazon put all of that money into the public education system? These are the kinds of arguments Galloway pounds home in this book.\nOne of my favorite arguments is in the Apple chapter, where he talks about the sex appeal that the company generates. It\u0026rsquo;s unlikely that a $1000 iPhone is much better than an Android that is $400 cheaper, but people have come to idolize Apple products and see them as \u0026ldquo;sexy\u0026rdquo;. Apple generates a colossal amount of revenue with this stigma.\nBiggest Takeaway: Yes, these companies have near-monopolies in their respective sectors, but they have carefully crafted these monopolies. They\u0026rsquo;re extremely good at what they do, and unless we find another company that does e-commerce better than Amazon or search better than Google, we have to deal with what we\u0026rsquo;ve got.\n All successful businesses appeal to one of three areas of the body — the brain, the heart, or the genitals. (163)\n Find this book (ironically) on Amazon .\nCat\u0026rsquo;s Cradle by Kurt Vonnegut #    This is the lone fiction book I read this summer, and I absolutely loved it. I had read Slaughterhouse-Five and Breakfast of Champions before and loved them both, so I was sure that Cat\u0026rsquo;s Cradle would not disappoint, and it did not.\nThe book follows the main protagonist Jonah as he looks to learn more about the creator of the atom bomb, Felix Hoenikker. He ends up travelling to the fictional San Lorenzo with Hoenikker\u0026rsquo;s children Frank, Newton, and Angela. Their father also invented a substance called ice-nine, which turns any water that it touches into water immediately.\nThe book is largely an argument on war and the arms race, with subtle hints about religion. This book is a quick read and I highly recommend it to anyone.\nBiggest Takeaway: anything can change in a moment\u0026rsquo;s notice. Make sure to take everything all in while you still can.\nFind this book on Amazon .\nThink and Grow Rich by Napoleon Hill #    This book, along with How to Win Friends and Influence People by Dale Carnegie, is considered one of the original self-help books. Written in 1937, this book contains a 12-step program toward achieving your financial goals.\nTo be honest, I was not a huge fan of this book. Hill takes finance from a very spiritual perspective, talking about \u0026ldquo;raising frequencies of thoughts\u0026rdquo; so that the \u0026ldquo;Infinite Intelligence\u0026rdquo; can receive them. He talks a lot about how to train your sub-conscious mind to receive better ideas.\nAlthough, one point that I really appreciated was his argument about the necessity of having a crystal clear vision of what you want. Saying \u0026ldquo;I want money\u0026rdquo; does not suffice; instead, try \u0026ldquo;I want money from creating a successful and profitable iPhone application that I will release in December of this year\u0026rdquo; (possible foreshadowing from Dylan???)\nBiggest Takeaway: make a clear plan for creating the wealth that you desire. Read it to yourself every day, and never let it slip your mind. Get as specific as possible.\n The successful leader must plan his work, and work his plan. (128)\n Find this book on Amazon .\nEffective Java by Josh Bloch #    This book needs no explanation. It\u0026rsquo;s simply the best book out there on Java development, and is an absolutely necessity for anyone consistently using Java. He talks not only about design patterns, but also about common Java libraries and how to use them effectively. Please read this book.\nBiggest Takeaway: Streams. Are. Awesome.\nFind this book on Amazon .\n","date":"15 August 2019","permalink":"/blog/books-i-read-this-summer/","section":"","summary":"One of my favorite things about the summers is how much time I have to catch up on reading.","title":"Books I Read This Summer"},{"content":"","date":"15 August 2019","permalink":"/tags/facebook/","section":"Tags","summary":"","title":"facebook"},{"content":"","date":"15 August 2019","permalink":"/tags/fiction/","section":"Tags","summary":"","title":"fiction"},{"content":"","date":"15 August 2019","permalink":"/tags/google/","section":"Tags","summary":"","title":"google"},{"content":"","date":"15 August 2019","permalink":"/tags/java/","section":"Tags","summary":"","title":"java"},{"content":"","date":"15 August 2019","permalink":"/tags/money/","section":"Tags","summary":"","title":"money"},{"content":"","date":"15 August 2019","permalink":"/tags/non-fiction/","section":"Tags","summary":"","title":"non-fiction"},{"content":"","date":"15 August 2019","permalink":"/tags/productivity/","section":"Tags","summary":"","title":"productivity"},{"content":"","date":"15 August 2019","permalink":"/tags/wall-street/","section":"Tags","summary":"","title":"wall street"},{"content":"I’m about to finish up my internship as a Software Engineer Intern at Yext in New York City (HQ). Over the past 12 weeks, I’ve learned a lot not only about Java, but also about best practices and how to truly succeed as a developer in today’s fast-moving world. I wanted to share these lessons, hoping that some of you can apply them as you try to make the next step in your career.\nWrite Code for Humans, not for Machines # I learned this quickly and early on, as a lot of my code review comments related to naming conventions or making code blocks easier to digest for other developers. After learning this, I believe that every developer needs to apply this mantra as early as possible. It’s the quickest and most surefire way to show that you have what it takes to become an elite contributor.\nYou will spend a lot of your time reading code, especially as an intern. When somebody hands you a new project or bug fix on a service that you have never touched before, you will usually spend the first hour or so just digesting code. Unfortunately, this initial read-through can get quite drawn out if the code doesn’t make sense to an average person.\n   Readability is king. It makes teams more efficient and agile, and the program will work the exact same regardless. Consider the following Java code snippets, both of which always return the same result:\nMap\u0026lt;Long, Long\u0026gt; convert(Map\u0026lt;Long, Long\u0026gt; map1, Map\u0026lt;Long, Long\u0026gt; map2) { Map\u0026lt;Long, Long\u0026gt; ret = new HashMap\u0026lt;\u0026gt;(); for (Map.Entry\u0026lt;Long, Long\u0026gt; e : map1.entrySet()) { ret.put(e.getKey(), map2.get(e.getValue())); } return ret; } Map\u0026lt;Long, Long\u0026gt; getCustomerIdToProductId( Map\u0026lt;Long, Long\u0026gt; customerIdToPurchaseId, Map\u0026lt;Long, Long\u0026gt; purchaseIdToProductId) { Map\u0026lt;Long, Long\u0026gt; customerIdToProductId = new HashMap\u0026lt;\u0026gt;(); for (Map.Entry\u0026lt;Long, Long\u0026gt; entry : customerIdToPurchaseId.entrySet()) { customerIdToProductId.put(entry.getKey(), purchaseIdToProductId.get(entry.getValue()); } return customerIdToProductId; }  Clearly, the first example gives no indication what *actually *gets computed in the snippet. The developer that wrote the code knew what the code did, so he or she felt no need to write comments or name variables appropriately. As a consequence, any future developer reading the snippet would struggle immensely to understand what happens in the code.\nConversely, the second snippet explains everything. The method declaration conveys the purpose of the method, and the variable names communicate the data that they hold clearly and concisely. Any future developer would have no trouble quickly understanding what this code does. This makes a world of difference in small teams, especially when dealing with large code bases.\nWhat I learned: Don’t just write code that works; write code that works and is readable, concise, and effective. Yes, it requires a little more effort to name things carefully, but I guarantee your team members will thank you for it later. This will speed up processes for years to come, and it shows that you understand that code is not only for machines to read.\nPlan First # On one of my larger stories this summer, I tried to start immediately without planning. For the first ten or so hours, things seemed to be going fine. I had written several classes, interfaces, and tests, and had confidence that all of the inputs and outputs worked correctly. Later on, I discovered that the way I had implemented the system wasn’t compliant with existing infrastructure — essentially, I had to rewrite the code from scratch 😢.\nEspecially when taking on larger stories/projects, do not ever dive into the code before planning. Yes, we all know the fun part of the job involves writing lines upon lines of code and seeing it work in production. However, without proper planning (the admittedly not-as-exciting part of the job), it’ll be much harder to ever see your code in production.\n   The way I see it, planning involves several steps, each of them equally important:\n  Define the problem in the most specific way possible. This way, you know exactly what to think about in the next step.\n  Think about the problem from a birds-eye view, and determine the high-level classes or components that will comprise the system. Then, define how those components will interact with each other.\n  Break the task down into several smaller sub-tasks, and get to work.\n  After my initial mistake, I made a promise to always spend at least 10% of the estimated time for a task planning for it. What I learned: By planning things out and batching them into small sub-tasks, you can actually produce effective code much quicker than before.\nI also find it very useful to draw system diagrams. Don’t just write in words what you plan to do, but get creative with shapes and lines to really visualize how a whole system will come together. If necessary, tear this page out of your notebook so that you can always see it throughout the whole development process. This made me a more effective developer this summer because I could easily detect code smells and know which classes interacted with each other.\nAsk Lots of Questions # I mean LOTS of questions. I genuinely think it would take me hours to scroll through my Slack messages with my mentor — because I never relented in asking questions. At first, I was admittedly scared of asking too many questions; I thought it made me look amateur, like I didn’t deserve to have this job. However, my mentor and my team quickly assured me that I not only can ask more questions, but I should ask more questions. Instead of being indicative of lack of experience (negative), it’s actually highly indicative of natural curiosity (a huge positive in the engineering world).\nSo I did. I asked questions about Java. I asked questions about design patterns. I asked questions about things from tech culture to message processing to career advancement. If I didn’t understand how something worked, I walked across the room and asked someone who knew how that thing worked. People were always happy to spend any amount of time explaining something to me, which I am beyond grateful for.\nWhat I learned: It’s much more important to understand the “how”, rather than just the “what”, and asking questions is a great way to bridge the gap. Understanding the “what” means understanding what code works in certain areas, and what code doesn’t. This doesn’t indicate any high-level understanding, but merely shows ability to remember things well. Understanding the “how” is much more impressive, because it means the ability to think deeply about systems and apply that knowledge when making future systems. By asking questions, I could finally understand how the architectural components work together, and how to approach problems at a high level on my own. Now, when in the process of planning, I write down several questions that I later ask to the owner of the service that I’m working on.\nBonus: when asking questions, try to do it in person rather than over Slack/IM. It’s a lot more personal, and it allows you to ask follow-up questions much faster.\nI would not trade this experience for anything in the world. Yext is a fast-growing company full of extremely talented individuals that I consider myself lucky to surround myself with. I’ve learned a lot about both tech and myself throughout this incredible summer in the center of the universe, New York City.\nI’ve grown more this summer as a developer than maybe in my first three years of undergrad. I realized there’s so much that the undergraduate education that gets left out, but I’m forever grateful for getting the opportunity to learn so all of the other bits and pieces this summer.\n","date":"13 August 2019","permalink":"/blog/lessons-i-learned-as-an-intern/","section":"","summary":"I’m about to finish up my internship as a Software Engineer Intern at Yext in New York City (HQ).","title":"Lessons I Learned as an Intern"},{"content":"Today we’re going to talk about what I think is Swift’s coolest feature — extensions.\nExtensions allow you to add functionality to an already existing class. In one of my recent projects, I implemented an OCR model that could read text (specifically, a credit card number) from a picture that the user took with the back camera. Unfortunately, if the image wasn’t oriented upwards, the OCR fails, as we would expect. As such, I needed a convenient way to change the orientation of the image with ease.\n   I quickly found some code that could easily convert an image (thanks to GitHub user Johannes Schickling for this). Here are the workflows with and without extensions:\nWithout Extensions # Without extensions, the workflow is similar to that of any typical Object-Oriented language. The developer would create a class that performed the orientation fix, and name it accordingly:\nclass ImageOrientationFixer { init() { } }  The user would then write a method that takes the image as a parameter, and returns an image with the new fixed orientation.\nclass ImageOrientationFixer { init() { } func changeOrientationToUpright(_ image : UIImage) -\u0026gt; UIImage { // code to correct the orientation } }  There are two major problems with this:\n  In every subsequent class that requires this functionality, we would have to instantiate a new ImageOrientationFixer . A quick solution would be to just make the method static , which leads into\n  This requires passing the image object to the fixer on every call. Any situation where a client calls a function, passes it a mutable object, and receives the same (modified) object in return is a blatant code smell, and indicative of a poorly designed API.\n  Alternatively, the method could return void and simply change some attributes of the image along the way. However, since the callee can still change the image at will, this is still a code smell.\nWith Extensions # Extensions fix both of the problems outlined above. Instead of creating a new class that does this, we can add that functionality to Swift’s UIImage class. This means that we can just directly call our new function on the image object itself. This solves the problems outlined above, because the client then never gives up control of the image object. The declaration looks like this:\nextension UIImage { func changeOrientationToUpright() { // code to correct the orientation } }  Then, anytime I want to change the orientation of some image object that I have, I simply call image.changeOrientationToUpright() and all my dreams come true.\nExtensions have a multitude of use cases, all of which make any mobile developer’s life much easier. Most importantly, they eliminate cases where a client would otherwise pass a mutable object to another class for processing. If you haven’t already, give Extensions a shot!\n","date":"13 August 2019","permalink":"/blog/extensions-in-swift/","section":"","summary":"Today we’re going to talk about what I think is Swift’s coolest feature — extensions.","title":"Extensions in Swift"}]